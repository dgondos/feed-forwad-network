<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Feed Forward Network</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #f5f6fa;
      color: #1f2933;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    header {
      padding: 1.5rem 2rem 0.5rem;
    }

    header h1 {
      margin: 0 0 0.4rem;
      font-size: 1.9rem;
    }

    header p {
      margin: 0;
      max-width: 60ch;
      color: #52606d;
    }

    .network-wrapper {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1.5rem 2rem 2.5rem;
    }

    #network {
      position: relative;
      width: clamp(760px, 90vw, 1100px);
      height: clamp(540px, 75vh, 760px);
      background: #fff;
      border-radius: 1.5rem;
      box-shadow: 0 20px 60px rgba(15, 23, 42, 0.12);
      padding: 2.5rem 3rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      overflow: hidden;
    }

    .layers {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      height: 100%;
      position: relative;
      z-index: 2;
      pointer-events: none;
    }

    .layer {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 1.6rem;
      position: relative;
      pointer-events: none;
    }

    .layer-label {
      position: absolute;
      top: 0.4rem;
      font-size: 0.82rem;
      color: #829ab1;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-weight: 600;
    }

    .neuron-block {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.6rem;
      pointer-events: none;
    }

    .neuron-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #52606d;
      pointer-events: none;
    }

    .neuron {
      width: 92px;
      height: 92px;
      border-radius: 50%;
      border: 3px solid #d9e2ec;
      background: linear-gradient(145deg, #f8fafc, #e4ecf4);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: inset 0 4px 10px rgba(148, 163, 184, 0.3);
      font-size: 1.05rem;
      font-weight: 600;
      color: #102a43;
      pointer-events: none;
      position: relative;
      z-index: 3;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      will-change: transform;
    }

    .neuron--clickable {
      pointer-events: auto;
      cursor: pointer;
    }

    .neuron--clickable:hover {
      transform: scale(1.08);
      box-shadow: inset 0 6px 14px rgba(148, 163, 184, 0.38), 0 14px 26px rgba(15, 23, 42, 0.22);
    }

    svg#connections {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      overflow: visible;
      z-index: 1;
    }

    svg#connections line {
      stroke-width: 4.8;
      stroke-linecap: round;
      opacity: 0.9;
      pointer-events: visibleStroke;
      cursor: pointer;
      transition: stroke-width 0.18s ease;
    }

    #weight-panel {
      position: absolute;
      top: 0;
      left: 0;
      display: none;
      flex-direction: column;
      gap: 0.6rem;
      padding: 0.75rem 0.9rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(255, 255, 255, 0.98);
      box-shadow: 0 20px 48px rgba(15, 23, 42, 0.18);
      z-index: 4;
      min-width: 160px;
    }

    #neuron-panel {
      position: absolute;
      top: 0;
      left: 0;
      display: none;
      flex-direction: column;
      gap: 0.7rem;
      padding: 0.9rem 1.05rem;
      border-radius: 0.85rem;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(250, 252, 255, 0.98);
      box-shadow: 0 22px 52px rgba(15, 23, 42, 0.22);
      z-index: 4;
      min-width: 240px;
      max-width: 320px;
    }

    .neuron-expression {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.82rem;
      color: #243b53;
    }

    .neuron-expression-list {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .neuron-expression-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.25rem 0.4rem;
      border-radius: 0.5rem;
      background: rgba(226, 232, 240, 0.45);
      border-left: 3px solid transparent;
      transition: background 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
    }

    .neuron-expression-line span {
      font-family: "SFMono-Regular", "Fira Code", "Roboto Mono", monospace;
      font-size: 0.78rem;
      letter-spacing: 0.01em;
      color: #0b2541;
    }

    .neuron-expression-line:hover,
    .neuron-expression-line--active {
      background: rgba(251, 146, 60, 0.24);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
      transform: translateX(4px);
      border-left: 3px solid #fb923c;
    }

    .neuron-expression-summary {
      margin-top: 0.4rem;
      padding-top: 0.4rem;
      border-top: 1px solid rgba(148, 163, 184, 0.45);
      font-size: 0.8rem;
      font-weight: 600;
      color: #102a43;
    }

    .neuron-expression-summary strong {
      font-weight: 700;
    }

    .neuron-expression-note {
      font-size: 0.8rem;
      color: #52606d;
    }

    #weight-panel button {
      border: none;
      background: none;
      cursor: pointer;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.82rem;
      font-weight: 600;
      color: #486581;
    }

    .panel-close {
      width: 1.4rem;
      height: 1.4rem;
      border-radius: 0.4rem;
      background: #e4ecf4;
      color: #102a43;
      font-weight: 700;
      transition: background 0.24s ease;
    }

    .panel-close:hover {
      background: #cbd2d9;
    }

    .panel-body {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 0.9rem;
    }

    .neuron-panel-body {
      justify-content: flex-start;
    }

    .panel-value {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .panel-value-label {
      font-size: 0.72rem;
      color: #829ab1;
    }

    .weight-value {
      font-size: 1.05rem;
      font-weight: 700;
      color: #102a43;
    }

    .panel-controls {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.45rem;
      margin-top: 0.35rem;
    }

    #weight-panel .panel-controls button {
      border: 1px solid #0b2541;
      border-radius: 0.65rem;
      background: linear-gradient(135deg, #1a3359, #244679);
      color: #fdfdff;
      font-size: 0.95rem;
      font-weight: 700;
      padding: 0.5rem 0.4rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.2rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.22);
      transition: transform 0.12s ease, box-shadow 0.15s ease, background 0.2s ease, color 0.2s ease;
    }

    #weight-panel .panel-controls button:hover {
      background: linear-gradient(135deg, #20365a, #1a2e4b);
      box-shadow: 0 10px 22px rgba(15, 23, 42, 0.28);
      color: #ffffff;
    }

    #weight-panel .panel-controls button:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 3px 8px rgba(15, 23, 42, 0.28);
    }

    #weight-panel .panel-controls button:focus-visible {
      outline: 2px solid rgba(59, 130, 246, 0.7);
      outline-offset: 2px;
    }

    footer {
      padding: 0.8rem 2rem 1.6rem;
      color: #829ab1;
      font-size: 0.82rem;
      text-align: center;
    }

    @media (max-width: 960px) {
      #network {
        padding: 2rem 1.6rem;
      }

      .neuron {
        width: 80px;
        height: 80px;
      }

      #weight-panel {
        min-width: 140px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Interactive Feed Forward Network</h1>
    <p>Adjust the connection weights and watch the forward pass update instantly. Inputs remain fixed while every hidden and output neuron recomputes its value after each tweak.</p>
  </header>

  <div class="network-wrapper">
    <div id="network">
      <svg id="connections"></svg>
      <div id="weight-panel">
        <div class="panel-header">
          <span class="panel-title">Connection</span>
          <button type="button" class="panel-close">X</button>
        </div>
        <div class="panel-body">
          <div class="panel-value">
            <span class="panel-value-label">Weight</span>
            <span class="weight-value">0.00</span>
          </div>
        </div>
        <div class="panel-controls">
          <button type="button" data-delta="0.1">+ 0.1</button>
          <button type="button" data-delta="-0.1">- 0.1</button>
        </div>
      </div>
      <div id="neuron-panel">
        <div class="panel-header">
          <span class="panel-title">Neuron</span>
          <button type="button" class="panel-close">X</button>
        </div>
        <div class="panel-body neuron-panel-body">
          <div class="panel-value">
            <span class="panel-value-label">Output</span>
            <span class="neuron-output-value">0.00</span>
          </div>
        </div>
        <div class="neuron-expression"></div>
      </div>
      <div class="layers"></div>
    </div>
  </div>

  <footer>Weights increment and decrement by 0.1. Line colours reveal the weight sign and strength.</footer>

  <script>
    (function () {
      const inputValues = [0.2, 0.5, 0.8, 0.3];
      const hiddenLayers = [3, 2];
      const layerSizes = [inputValues.length, ...hiddenLayers, 1];

      const networkEl = document.getElementById('network');
      const layersEl = networkEl.querySelector('.layers');
      const svgEl = document.getElementById('connections');
      const weightPanel = document.getElementById('weight-panel');
      const weightPanelTitle = weightPanel.querySelector('.panel-title');
      const weightValueEl = weightPanel.querySelector('.weight-value');
      const weightAdjustButtons = weightPanel.querySelectorAll('[data-delta]');
      const weightCloseBtn = weightPanel.querySelector('.panel-close');
      const neuronPanel = document.getElementById('neuron-panel');
      const neuronPanelTitle = neuronPanel.querySelector('.panel-title');
      const neuronOutputValueEl = neuronPanel.querySelector('.neuron-output-value');
      const neuronExpressionEl = neuronPanel.querySelector('.neuron-expression');
      const neuronCloseBtn = neuronPanel.querySelector('.panel-close');

      const neuronsByLayer = [];
      const connections = [];
      const expressionHighlightColor = '#fb923c';
      let activeConnection = null;
      let activeNeuron = null;

      function formatNumber(value) {
        const rounded = Math.round(value * 100) / 100;
        return rounded.toFixed(2);
      }

      function makeNeuronLabel(layerIndex, neuronIndex) {
        if (layerIndex === 0) {
          return `Input ${neuronIndex + 1}`;
        }
        if (layerIndex === layerSizes.length - 1) {
          return 'Output';
        }
        return `Hidden ${layerIndex}-${neuronIndex + 1}`;
      }

      function weightToColor(weight) {
        const clamp = Math.max(-2, Math.min(2, weight));
        const magnitude = Math.min(1, Math.abs(clamp) / 2);
        const lightness = 65 - magnitude * 25;
        const hue = clamp >= 0 ? 210 : 0;
        return `hsl(${hue}, 72%, ${lightness}%)`;
      }

      function weightToStroke(weight) {
        const base = 4.0;
        const extra = Math.min(2.5, Math.abs(weight));
        return base + extra * 0.8;
      }

      function refreshConnectionStroke(connection) {
        const hoverBonus = (connection.isPointerHover ? 3 : 0) + (connection.isExpressionHover ? 4 : 0);
        const strokeWidth = connection.baseStroke + hoverBonus;
        const color = connection.isExpressionHover ? expressionHighlightColor : weightToColor(connection.weight);
        connection.line.setAttribute('stroke', color);
        connection.line.setAttribute('stroke-width', strokeWidth);
      }

      function buildLayers() {
        layerSizes.forEach((count, layerIndex) => {
          const layer = [];
          const layerEl = document.createElement('div');
          layerEl.className = 'layer';

          const labelEl = document.createElement('div');
          labelEl.className = 'layer-label';
          if (layerIndex === 0) {
            labelEl.textContent = 'Input Layer';
          } else if (layerIndex === layerSizes.length - 1) {
            labelEl.textContent = 'Output Layer';
          } else {
            labelEl.textContent = `Hidden Layer ${layerIndex}`;
          }
          layerEl.appendChild(labelEl);

          for (let i = 0; i < count; i += 1) {
            const blockEl = document.createElement('div');
            blockEl.className = 'neuron-block';

            const titleEl = document.createElement('div');
            titleEl.className = 'neuron-label';
            titleEl.textContent = makeNeuronLabel(layerIndex, i);

            const neuronEl = document.createElement('div');
            neuronEl.className = 'neuron';

            const valueEl = document.createElement('div');
            valueEl.className = 'neuron-value';
            valueEl.textContent = '0.00';
            neuronEl.appendChild(valueEl);

            blockEl.appendChild(titleEl);
            blockEl.appendChild(neuronEl);
            layerEl.appendChild(blockEl);

            const neuronData = {
              layerIndex,
              index: i,
              element: neuronEl,
              valueEl,
              titleEl,
              incoming: [],
              outgoing: [],
              value: 0,
              midX: 0,
              midY: 0
            };

            if (layerIndex > 0) {
              neuronEl.classList.add('neuron--clickable');
              neuronEl.addEventListener('click', (event) => {
                event.stopPropagation();
                showNeuronPanel(neuronData);
              });
            }

            layer.push(neuronData);
          }

          neuronsByLayer.push(layer);
          layersEl.appendChild(layerEl);
        });
      }

      function buildConnections() {
        for (let layerIndex = 0; layerIndex < neuronsByLayer.length - 1; layerIndex += 1) {
          const currentLayer = neuronsByLayer[layerIndex];
          const nextLayer = neuronsByLayer[layerIndex + 1];

          currentLayer.forEach((fromNeuron) => {
            nextLayer.forEach((toNeuron) => {
              const weight = Math.round((Math.random() * 2 - 1) * 10) / 10;
              const baseStroke = weightToStroke(weight);

              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('stroke', weightToColor(weight));
              line.setAttribute('stroke-width', baseStroke);
              svgEl.appendChild(line);

              const label = `${fromNeuron.titleEl.textContent} -> ${toNeuron.titleEl.textContent}`;

              const connection = {
                from: fromNeuron,
                to: toNeuron,
                weight,
                line,
                label,
                midX: 0,
                midY: 0,
                lastInput: 0,
                lastContribution: 0,
                baseStroke,
                isPointerHover: false,
                isExpressionHover: false,
                id: null
              };

              fromNeuron.outgoing.push(connection);
              toNeuron.incoming.push(connection);
              connections.push(connection);
              connection.id = connections.length - 1;
              line.setAttribute('data-connection-id', String(connection.id));
              refreshConnectionStroke(connection);
              line.addEventListener('pointerdown', (event) => {
                event.stopPropagation();
                showWeightPanel(connection);
              });
              line.addEventListener('pointerenter', () => {
                connection.isPointerHover = true;
                refreshConnectionStroke(connection);
              });
              line.addEventListener('pointerleave', () => {
                connection.isPointerHover = false;
                refreshConnectionStroke(connection);
              });
            });
          });
        }
      }

      function updateConnectionVisual(connection) {
        connection.line.setAttribute('stroke', weightToColor(connection.weight));
        connection.baseStroke = weightToStroke(connection.weight);
        refreshConnectionStroke(connection);
        if (connection === activeConnection) {
          weightValueEl.textContent = formatNumber(connection.weight);
        }
      }

      function applyWeightChange(connection, delta) {
        if (!connection) {
          return;
        }
        const scaled = Math.round(connection.weight * 10);
        const newScaled = scaled + Math.round(delta * 10);
        connection.weight = newScaled / 10;
        updateConnectionVisual(connection);
        recomputeNetwork();
      }

      function recomputeNetwork() {
        neuronsByLayer[0].forEach((neuron, index) => {
          neuron.value = inputValues[index];
          neuron.valueEl.textContent = formatNumber(neuron.value);
        });

        for (let layerIndex = 1; layerIndex < neuronsByLayer.length; layerIndex += 1) {
          const layer = neuronsByLayer[layerIndex];
          layer.forEach((neuron) => {
            let sum = 0;
            neuron.incoming.forEach((connection) => {
              const inputVal = connection.from.value;
              const contribution = inputVal * connection.weight;
              connection.lastInput = inputVal;
              connection.lastContribution = contribution;
              sum += contribution;
            });
            neuron.value = sum;
            neuron.valueEl.textContent = formatNumber(neuron.value);
          });
        }

        if (activeNeuron) {
          updateNeuronPanelContent(activeNeuron);
          placeNeuronPanel(activeNeuron);
        }
      }

      function positionConnections() {
        const networkRect = networkEl.getBoundingClientRect();
        connections.forEach((connection) => {
          const fromRect = connection.from.element.getBoundingClientRect();
          const toRect = connection.to.element.getBoundingClientRect();

          const x1 = fromRect.left + fromRect.width / 2 - networkRect.left;
          const y1 = fromRect.top + fromRect.height / 2 - networkRect.top;
          const x2 = toRect.left + toRect.width / 2 - networkRect.left;
          const y2 = toRect.top + toRect.height / 2 - networkRect.top;

          connection.line.setAttribute('x1', x1);
          connection.line.setAttribute('y1', y1);
          connection.line.setAttribute('x2', x2);
          connection.line.setAttribute('y2', y2);

          connection.midX = (x1 + x2) / 2;
          connection.midY = (y1 + y2) / 2;
        });

        if (activeConnection) {
          placeWeightPanel(activeConnection);
        }
        if (activeNeuron) {
          placeNeuronPanel(activeNeuron);
        }
      }

      function placeWeightPanel(connection) {
        if (!connection || weightPanel.style.display === 'none') {
          return;
        }
        const padding = 16;
        const panelWidth = weightPanel.offsetWidth;
        const panelHeight = weightPanel.offsetHeight;
        const maxLeft = networkEl.clientWidth - panelWidth - padding;
        const maxTop = networkEl.clientHeight - panelHeight - padding;

        let left = connection.midX - panelWidth / 2;
        let top = connection.midY - panelHeight - 20;

        if (top < padding) {
          top = connection.midY + 20;
        }

        left = Math.max(padding, Math.min(left, maxLeft));
        top = Math.max(padding, Math.min(top, maxTop));

        weightPanel.style.left = `${left}px`;
        weightPanel.style.top = `${top}px`;
      }

      function placeNeuronPanel(neuron) {
        if (!neuron || neuronPanel.style.display === 'none') {
          return;
        }
        const padding = 16;
        const panelWidth = neuronPanel.offsetWidth;
        const panelHeight = neuronPanel.offsetHeight;
        const networkRect = networkEl.getBoundingClientRect();
        const neuronRect = neuron.element.getBoundingClientRect();

        const centerX = neuronRect.left + neuronRect.width / 2 - networkRect.left;
        const centerY = neuronRect.top + neuronRect.height / 2 - networkRect.top;

        let left = centerX + 60;
        let top = centerY - panelHeight / 2;

        const maxLeft = networkEl.clientWidth - panelWidth - padding;
        const maxTop = networkEl.clientHeight - panelHeight - padding;

        if (left > maxLeft) {
          left = centerX - panelWidth - 60;
        }

        left = Math.max(padding, Math.min(left, maxLeft));
        top = Math.max(padding, Math.min(top, maxTop));

        neuronPanel.style.left = left + 'px';
        neuronPanel.style.top = top + 'px';
      }

      function buildNeuronExpression(neuron) {
        if (!neuron.incoming.length) {
          return {
            lines: [],
            summaryParts: [],
            note: 'This neuron holds a fixed input value of ' + formatNumber(neuron.value) + '.'
          };
        }

        const lines = neuron.incoming.map((connection) => ({
          term: formatNumber(connection.lastInput) + ' * ' + formatNumber(connection.weight),
          result: formatNumber(connection.lastContribution),
          connectionId: connection.id
        }));

        const summaryParts = neuron.incoming.map((connection) => formatNumber(connection.lastInput) + ' * ' + formatNumber(connection.weight));

        return {
          lines,
          summaryParts,
          note: ''
        };
      }

      function updateNeuronPanelContent(neuron) {
        neuron.incoming.forEach((connection) => {
          connection.isExpressionHover = false;
          refreshConnectionStroke(connection);
        });

        const expression = buildNeuronExpression(neuron);
        neuronPanelTitle.textContent = neuron.titleEl.textContent;
        neuronOutputValueEl.textContent = formatNumber(neuron.value);

        if (expression.note) {
          neuronExpressionEl.innerHTML = '<div class="neuron-expression-note">' + expression.note + '</div>';
          return;
        }

        const lineMarkup = expression.lines
          .map((entry) => '<div class="neuron-expression-line" data-connection-id="' + entry.connectionId + '"><span>' + entry.term + '</span><span>' + entry.result + '</span></div>')
          .join('');

        const summaryText = expression.summaryParts.join(' + ');
        neuronExpressionEl.innerHTML =
          '<div class="neuron-expression-list">' + lineMarkup + '</div>' +
          '<div class="neuron-expression-summary">' + summaryText + ' = <strong>' + formatNumber(neuron.value) + '</strong></div>';

        const expressionLines = neuronExpressionEl.querySelectorAll('.neuron-expression-line');
        expressionLines.forEach((lineEl) => {
          const idAttr = lineEl.getAttribute('data-connection-id');
          if (!idAttr) {
            return;
          }
          const connection = connections[Number(idAttr)];
          if (!connection) {
            return;
          }
          lineEl.addEventListener('mouseenter', () => {
            connection.isExpressionHover = true;
            lineEl.classList.add('neuron-expression-line--active');
            refreshConnectionStroke(connection);
          });
          lineEl.addEventListener('mouseleave', () => {
            connection.isExpressionHover = false;
            lineEl.classList.remove('neuron-expression-line--active');
            refreshConnectionStroke(connection);
          });
        });
      }

      function showNeuronPanel(neuron) {
        hideWeightPanel();
        activeNeuron = neuron;
        updateNeuronPanelContent(neuron);
        neuronPanel.style.display = 'flex';
        requestAnimationFrame(() => {
          placeNeuronPanel(neuron);
        });
      }

      function hideNeuronPanel() {
        if (activeNeuron) {
          activeNeuron.incoming.forEach((connection) => {
            if (connection.isExpressionHover) {
              connection.isExpressionHover = false;
              refreshConnectionStroke(connection);
            }
          });
        }
        neuronExpressionEl.querySelectorAll('.neuron-expression-line--active').forEach((lineEl) => {
          lineEl.classList.remove('neuron-expression-line--active');
        });
        activeNeuron = null;
        neuronPanel.style.display = 'none';
      }

      function showWeightPanel(connection) {
        hideNeuronPanel();
        activeConnection = connection;
        weightPanelTitle.textContent = connection.label;
        weightValueEl.textContent = formatNumber(connection.weight);
        weightPanel.style.display = 'flex';
        requestAnimationFrame(() => {
          placeWeightPanel(connection);
        });
      }

      function hideWeightPanel() {
        activeConnection = null;
        weightPanel.style.display = 'none';
      }

      function attachEventHandlers() {
        weightAdjustButtons.forEach((button) => {
          button.addEventListener('click', (event) => {
            event.stopPropagation();
            const delta = Number(button.getAttribute('data-delta'));
            if (!Number.isFinite(delta) || !activeConnection) {
              return;
            }
            applyWeightChange(activeConnection, delta);
          });
        });

        weightCloseBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          hideWeightPanel();
        });

        weightPanel.addEventListener('click', (event) => {
          event.stopPropagation();
        });

        neuronCloseBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          hideNeuronPanel();
        });

        neuronPanel.addEventListener('click', (event) => {
          event.stopPropagation();
        });

        svgEl.addEventListener('click', (event) => {
          const target = event.target;
          if (!target || typeof target.getAttribute !== 'function') {
            return;
          }
          if (String(target.tagName).toLowerCase() !== 'line') {
            return;
          }
          event.stopPropagation();
          const idAttr = target.getAttribute('data-connection-id');
          if (!idAttr) {
            return;
          }
          const connection = connections[Number(idAttr)];
          if (connection) {
            showWeightPanel(connection);
          }
        });

        networkEl.addEventListener('click', () => {
          if (activeConnection) {
            hideWeightPanel();
          }
          if (activeNeuron) {
            hideNeuronPanel();
          }
        });
      }

      function init() {
        buildLayers();
        buildConnections();
        recomputeNetwork();
        attachEventHandlers();
        positionConnections();
        window.addEventListener('resize', () => {
          window.requestAnimationFrame(positionConnections);
        });
      }

      window.addEventListener('load', () => {
        init();
        window.requestAnimationFrame(positionConnections);
      });
    })();
  </script>
</body>
</html>
